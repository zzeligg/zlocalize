# -*- encoding : utf-8 -*-

require 'rdoc'
require 'rdoc/options'
require 'rdoc/ruby_lex'
require File.join(File.dirname(__FILE__),'translation_file')
require File.join(File.dirname(__FILE__),'harvester')

module ZLocalize

  # base class for Expressions we're interested in
  class Expression #:nodoc: all
    attr_accessor :line_no
    attr_accessor :char_no
    attr_accessor :text
    attr_accessor :sub_method

    def initialize(line_no,char_no,text = '')
       @line_no, @char_no, @text = line_no, char_no, text
    end

    def set_text(t)
      @text = t
      self
    end

    # puts spaces before the output generated by +display+. Used for debugging purposes.
    def prefix(indent)
      ' ' * (indent*INDENT_STEP)
    end

    # display this Expression as a string. Used for debugging purposes
    def display(indent = 0)
      i = prefix(indent)
      i << "#{self.class.name} (#{line_no},#{char_no}): #{@text}\n"
    end

    # Since Expression is an abstract class, no output is generated
    # (descendants redefine this method)
    def to_translation_entry(filename)
      nil
    end

    def to_entry_string
      @text.force_encoding("UTF-8")
    end

    def is_translate_call
      false
    end
  end # class Expression

  # Basic identifier expression
  class IdentifierExpression < Expression  #:nodoc: all
    attr_accessor :name
    attr_accessor :parameters

    def initialize(line_no,char_no,name)
      @name = name
      @parameters = []
      @sub_method = nil
      super(line_no,char_no)
    end

    # Used for debugging
    def display(indent = 0)
      i = prefix(indent)
      i << "#{self.class.name} (#{line_no},#{char_no}): #{@name} (#{parameters.size} parameters)\n"
      @parameters.each { |p| i << p.display(indent+2) }
      unless @sub_method.nil?
        i << prefix(indent+1) + "sub-method:\n"
        i << @sub_method.display(indent+2)
      end
      i
    end

    # Convert ourselves to a Hash or an Array of Hashes which each represent
    # a call to a translate method.
    # Will only output something if this expression is an actual call to <tt>_</tt> or <tt>n_</tt>
    def to_translation_entry(filename)
      if ['_','n_'].include?(@name)
        params = @parameters.dup
      elsif @name == 'ZLocalize' && @sub_method.is_a?(IdentifierExpression) && ['pluralize','translate'].include?(@sub_method.name)
        params = @sub_method.parameters.dup
      else
        return nil
      end
      if params.size > 0
        p1 = params.shift
        # we only collect litteral strings and Arrays
        entry = []
        if [StringExpression,ArrayExpression].include?(p1.class)
          entry << TranslationEntry.new( 'plural'     => @name == 'n_',
                                         'source'     => p1.to_entry_string,
                                         'references' => [ "#{filename}:#{p1.line_no}" ])
        end
        # collect all other parameters to this call, in case they are themselves calls to nested _("")
        params.each { |p| entry << p.to_translation_entry(filename) }
        return entry.flatten.compact
      else
        nil
      end
    end

    def to_entry_string
      "(identifier '#{name}')".force_encoding("UTF-8")
    end

  end # class IdentifierExpression

  # a String Expression (litteral occurence of a string)
  class StringExpression < IdentifierExpression  #:nodoc: all

    def display(indent = 0)
      i = prefix(indent)
      i << "#{self.class.name} (#{line_no},#{char_no}): #{@name}\n"
      unless @sub_method.nil?
        i << prefix(indent+1) + "sub-method:\n"
        i << @sub_method.display(indent+2)
      end
      i
    end

    def to_entry_string
      ZLocalize.clean_ruby_string(@name).force_encoding("UTF-8")
      # @name
    end

  end #class StringExpression

  # a Number Expression
  class NumberExpression < IdentifierExpression  #:nodoc: all

    def display(indent = 0)
      i = prefix(indent)
      i << "#{self.class.name} (#{line_no},#{char_no}): #{@name}\n"
      unless @sub_method.nil?
        i << prefix(indent+1) + "sub-method:\n"
        i << @sub_method.display(indent+2)
      end
      i
    end

    def to_entry_string
      "\"(number '#{@name}')\"".force_encoding("UTF-8")
    end

  end  # class NumberExpression

  # a Symbol Expression
  class SymbolExpression < IdentifierExpression  #:nodoc: all

    def display(indent = 0)
      i = prefix(indent)
      i << "#{self.class.name} (#{line_no},#{char_no}): #{@name}\n"
      unless @sub_method.nil?
        i << prefix(indent+1) + "sub-method:\n"
        i << @sub_method.display(indent+2)
      end
      i
    end

    def to_entry_string
      "\"(symbol #{@name})\"".force_encoding("UTF-8")
    end

  end # class SymbolExpression

  class RangeExpression < IdentifierExpression  #:nodoc: all
    attr_accessor :low
    attr_accessor :high

    def display(indent = 0)
      p = prefix(indent)
      i = p + "#{self.class.name} (#{line_no},#{char_no})\n"
      i << p + "low:\n" + low.display(indent+1)
      i << p + "high:\n" + high.display(indent+1)
      i << "\n"
    end

    def to_entry_string
      return "\"(range)\"".force_encoding("UTF-8")
    end

  end # class RangeExpression

  # an Array declaration. It will hold its elements as a list of Expressions
  class ArrayExpression < IdentifierExpression #:nodoc: all

    attr_accessor :elements

    def initialize(line_no,char_no)
      super(line_no,char_no,'array')
      @elements = []
    end

    def display(indent = 0)
      i = super(indent)
      @elements.each { |e| i << e.display(indent+1) }
      i
    end

    def to_translation_entry(filename)
      @elements.collect { |elem| elem.to_translation_entry(filename) }.flatten.compact
    end

    def to_entry_string
      @elements.collect { |e| e.to_entry_string }
      # '[' + @elements.collect { |e| e.to_entry_string }.join(', ') + ']'
    end

  end # class ArrayExpression

  # a Hash declaration. Elements will be a Hash in which each element
  # will itself be a HashElementExpression like this:
  #    { :key => Expression, :value => Expression }
  class HashExpression < IdentifierExpression  #:nodoc: all

    attr_accessor :elements

    def initialize(line_no,char_no)
      super(line_no,char_no,'hash')
      @elements = []
    end

    def display(indent = 0)
      i = super(indent)
      @elements.each { |e| i << e.display(indent) }
      i
    end

    def to_translation_entry(filename)
      @elements.collect { |elem| elem.to_translation_entry(filename) }.flatten.compact
    end

    def to_entry_string
      '{ ' + @elements.collect { |e| e.to_entry_string }.compact.join(',') + ' }'.force_encoding("UTF-8")
    end

  end # class HashExpression

  # a Hash Element. It holds the key and the value of the element as Expressions
  class HashElementExpression < IdentifierExpression  #:nodoc: all
    attr_accessor :key
    attr_accessor :value

    def initialize(line_no,char_no)
      super(line_no,char_no,'hashElement')
    end

    def display(indent = 0)
      i = super(indent)
      i << prefix(indent) + "key:\n" + @key.display(indent+1)
      i << prefix(indent) + "value:\n" + @value.display(indent+1)
    end

    def to_translation_entry(filename)
      r = [key.to_translation_entry(filename),value.to_translation_entry(filename)].flatten.compact
    end

    def to_entry_string
      "#{key.to_entry_string} => #{value.to_entry_string}".force_encoding("UTF-8")
    end

  end # class HashElementExpression

   # an Operator expression holds the operator itself, and the operands
  class OperatorExpression < Expression  #:nodoc: all

    attr_accessor :operator
    attr_accessor :operands

    def initialize(line_no,char_no,op)
      super(line_no,char_no,op)
      @operands = []
      @operator = op
    end

    def display(indent = 0)
      p = prefix(indent)
      i = p + "#{self.class.name} (#{line_no},#{char_no})\n"
      @operands.each { |o| i << o.display(indent+1) }
      i
    end

    def to_translation_entry(filename)
      @operands.collect { |o| o.to_translation_entry(filename) }.flatten.compact
    end

    def to_entry_string
      @operands.collect { |o| o.to_entry_string }.join(" #{@operator} ").force_encoding("UTF-8")
    end

  end # class OperatorExpression

  # represents an 'inline-if' expression, as in:
  #    something ? when_true : when_false
  class ConditionalExpression < Expression  #:nodoc: all
    attr_accessor :condition
    attr_accessor :true_expr
    attr_accessor :false_expr

    def initialize(line_to,char_no)
      super(line_to,char_no,'?')
    end

    def display(indent = 0)
      i = prefix(indent) + "#{self.class.name} (#{line_no},#{char_no})\n"
      i << prefix(indent+1) + "condition:\n"
      i << @condition.display(indent+2)
      i << prefix(indent+1) + "when true:\n"
      i << @true_expr.display(indent+2)
      i << prefix(indent+1) + "when false:\n"
      i << @false_expr.display(indent+2)
      i
    end

    def to_translation_entry(filename)
      [condition.to_translation_entry(filename),
       true_expr.to_translation_entry(filename),
       false_expr.to_translation_entry(filename)].flatten.compact
    end

    def to_entry_string
      "#{conditions.as_entry_string} ? #{true_expr.as_entry_string} : #{false_expr.as_entry_string}".force_encoding("UTF-8")
    end

  end # class ConditionalExpression

  # any other Expression that we don't really care about
  class DontCareExpression < Expression  #:nodoc: all
  end


  OPERATOR_TOKENS = [RDoc::RubyToken::TkGT, RDoc::RubyToken::TkLT, RDoc::RubyToken::TkPLUS,
                     RDoc::RubyToken::TkMINUS, RDoc::RubyToken::TkMULT, RDoc::RubyToken::TkSTAR,
                     RDoc::RubyToken::TkDIV,
                     RDoc::RubyToken::TkMOD, RDoc::RubyToken::TkBITOR, RDoc::RubyToken::TkBITXOR,
                     RDoc::RubyToken::TkBITAND, RDoc::RubyToken::TkBITNOT, RDoc::RubyToken::TkNOTOP,
                     RDoc::RubyToken::TkPOW, RDoc::RubyToken::TkCMP, RDoc::RubyToken::TkEQ,
                     RDoc::RubyToken::TkEQQ, RDoc::RubyToken::TkNEQ, RDoc::RubyToken::TkGEQ,
                     RDoc::RubyToken::TkLEQ, RDoc::RubyToken::TkANDOP, RDoc::RubyToken::TkOROP,
                     RDoc::RubyToken::TkMATCH, RDoc::RubyToken::TkNMATCH, RDoc::RubyToken::TkLSHFT,
                     RDoc::RubyToken::TkRSHFT]

  UNARY_OP_TOKENS = [RDoc::RubyToken::TkPLUS,RDoc::RubyToken::TkMINUS,RDoc::RubyToken::TkBITNOT,RDoc::RubyToken::TkNOTOP]


  # Parses a Ruby (or ERB) file and generates a list of language tokens
  class SourceParser

    attr_accessor :translate_calls
    attr_accessor :in_hash
    attr_accessor :filename
    attr_accessor :root

    def initialize(filename, root, is_erb = false)
      @in_hash = 0
      @translate_calls = []
      @root = File.expand_path(root).downcase
      @filename = File.expand_path(filename).downcase
      @relative_filename = @filename.gsub(@root,'')
      content = File.open(filename, "r") { |f| f.read }
      if is_erb
        content = ERB.new(content).src
      end

      @lex = RDoc::RubyLex.new(content,RDoc::Options.new)
      @token_list = []
      while tk = @lex.token
        @token_list << tk
      end
      @token_index = -1
      @last_token_index = @token_list.size
    end

    def get_tk
      @token_index += 1
      if @token_index < @last_token_index
        @tk = @token_list[@token_index]
      else
        @tk = nil
      end
      @tk
    end

    def peek_tk
      peek_index = @token_index + 1
      return peek_index < @last_token_index ? @token_list[peek_index] : nil
    end

    def rewind
      @token_index = -1
    end

    def skip_white_space
      while [RDoc::RubyToken::TkNL, RDoc::RubyToken::TkSPACE].include?(@tk.class)
        get_tk
      end
    end

    # simply list the tokens in the source file
    def list_tokens
      while get_tk
        puts @tk.inspect
      end
    end

    def parse_error(tk,msg)
      raise(ParseError,"\n\nIn file #{@filename}, on line #{tk.line_no} at position #{tk.char_no}: " + msg + "\n\n")
    end

    # we simply detect calls to the ZLocalize methods and parse their parameter list
    def parse
      rewind
      while get_tk
        if @tk.is_a?(RDoc::RubyToken::TkCONSTANT) && @tk.text = 'ZLocalize'
          get_tk # should be a dot
          get_tk # either 'translate' or 'pluralize'
          parse_translate_call if ['translate','pluralize'].include?(@tk.text)
        elsif @tk.is_a?(RDoc::RubyToken::TkIDENTIFIER)
          parse_translate_call if ['_','n_'].include?(@tk.text)
        end
      end
     end

    # parse a call to one of the translation methods  <tt>_(...)</tt>, <tt>n_(...)</tt>
    def parse_translate_call
      m = IdentifierExpression.new(@tk.line_no,@tk.char_no,@tk.text)
      get_tk
      skip_white_space
      expect_r_paren = @tk.is_a?(RDoc::RubyToken::TkLPAREN)
      get_tk if expect_r_paren
      m.parameters = parse_parameters
      if expect_r_paren && !@tk.is_a?(RDoc::RubyToken::TkRPAREN)
        parse_error(@tk,"')' expected but '#{@tk.text}' (#{@tk.class.name}) found")
      end
      @translate_calls << m
      m
    end


    # parse the list of actual parameters to a method
    def parse_parameters
      parameters = []
      skip_white_space
      return if @tk.is_a?(RDoc::RubyToken::TkRPAREN)

      parameters << parse_expression
      skip_white_space
      while @tk.is_a?(RDoc::RubyToken::TkCOMMA) do
        get_tk
        parameters << parse_expression
        skip_white_space
      end
      parameters
    end

    # parse identifier(...), identifier[...] or identifier{...}
    def parse_identifier
      case @tk
        when RDoc::RubyToken::TkLPAREN
          ident_text = "(Method From Stack)"
        when RDoc::RubyToken::TkfLBRACK
          ident_text = "(Array Access)"
        else
          ident_text = @tk.text
          line, char = @tk.line_no, @tk.char_no
          get_tk
          # check for a Ruby 2.0 Hash key symbol (identifier directly followed by a COLON)
          if @tk.is_a?(RDoc::RubyToken::TkCOLON) || @tk.is_a?(RDoc::RubyToken::TkSYMBEG)
            expr = SymbolExpression.new(line,char,'')
            expr.set_text(ident_text + ':')
            expr.name = ident_text + ':'
            get_tk
            return expr
          end
      end
      ident = IdentifierExpression.new(@tk.line_no,@tk.char_no,ident_text)
      while(@tk.is_a?(RDoc::RubyToken::TkCOLON2))
        get_tk
        ident.name << '::' + @tk.text
        get_tk
      end

      case @tk
        when RDoc::RubyToken::TkLPAREN
          get_tk
          ident.parameters = parse_parameters
          unless @tk.is_a?(RDoc::RubyToken::TkRPAREN)
            parse_error(@tk,"')' expected but '#{@tk.text}' found")
          end
          get_tk
        when RDoc::RubyToken::TkfLBRACK
          get_tk
          ident.parameters = parse_parameters
          unless @tk.is_a?(RDoc::RubyToken::TkRBRACK)
            parse_error(@tk,"']' expected but '#{@tk.text}' found")
          end
          get_tk
      end # case @tk
      parse_identifier_method_call(ident)
    end # parse_identifier

    # parse the additional methods in an expression
    # for example:
    #   self.method.sub_method(1).another_sub_method(2)
    def parse_identifier_method_call(ident)
      case @tk
        when RDoc::RubyToken::TkDOT
          get_tk
          ident.sub_method = parse_identifier
        when RDoc::RubyToken::TkLPAREN, RDoc::RubyToken::TkfLBRACK
          ident.sub_method = parse_identifier
      end
      ident
    end

    # check if the expression currently being parsed as a range specifier
    def check_for_range_expression(expr)
      skip_white_space
      if [RDoc::RubyToken::TkDOT2,RDoc::RubyToken::TkDOT3].include?(@tk.class)
        range_expr = RangeExpression.new(expr.line_no,expr.char_no,'')
        range_expr.low = expr
        get_tk
        range_expr.high = parse_expression
        return range_expr
      else
        return expr
      end
    end

    # check if the expression is a hash element declaration (i.e. is it followed by <tt>=></tt>)
    def check_for_hash_element_expression(expr)
      return expr if @in_hash > 0
      if expr.is_a?(SymbolExpression) && expr.text =~ /:$/
        he_expr = HashElementExpression.new(expr.line_no,expr.char_no)
        he_expr.key = expr
        skip_white_space
        he_expr.value = parse_expression
        # get_tk
        return he_expr
      else
        skip_white_space
        if @tk.is_a?(RDoc::RubyToken::TkASSIGN)
          get_tk
          if @tk.is_a?(RDoc::RubyToken::TkGT)
            he_expr = HashElementExpression.new(expr.line_no,expr.char_no)
            he_expr.key = expr
            get_tk
            he_expr.value = parse_expression
            return he_expr
          end
        end
      end
      return expr
    end

    # parse an Expression, which can be either a simple identifier,
    # a method call with parameters, an operator expression (as in 1 + 1)
    # or an 'inline-if' expression
    def parse_expression
      skip_white_space
      expr1 = parse_operand
      skip_white_space
      if OPERATOR_TOKENS.include?(@tk.class)
        expr = OperatorExpression.new(expr1.line_no,expr1.char_no,'')
        expr.operands << expr1
        while OPERATOR_TOKENS.include?(@tk.class)
          get_tk
          expr.operands << parse_operand
        end
      else
        expr = expr1
      end
      skip_white_space
      if @tk.is_a?(RDoc::RubyToken::TkQUESTION)
        get_tk
        expr2 = ConditionalExpression.new(expr.line_no,expr.char_no)
        expr2.condition = expr1
        expr2.true_expr = parse_expression
        skip_white_space
        unless @tk.is_a?(RDoc::RubyToken::TkCOLON)
          parse_error(@tk,"':' expected but #{@tk.text} found")
        end
        get_tk
        expr2.false_expr = parse_expression
        expr = expr2
      end
      expr
    end

    # parse and return an operand to an OperatorExpression
    def parse_operand
      skip_white_space
      while UNARY_OP_TOKENS.include?(@tk.class)
        get_tk
        skip_white_space
      end
      case @tk
        when RDoc::RubyToken::TkLPAREN, RDoc::RubyToken::TkfLPAREN
          get_tk
          expr = parse_expression
          unless @tk.is_a?(RDoc::RubyToken::TkRPAREN)
            parse_error(@tk,"')' expected but #{@tk.text} found (unmatched parenthesis)")
          end
          get_tk
          expr = parse_identifier_method_call(expr)  # ident.something
          expr = check_for_range_expression(expr)
          expr = check_for_hash_element_expression(expr)
        when RDoc::RubyToken::TkSTRING, RDoc::RubyToken::TkDSTRING, RDoc::RubyToken::TkXSTRING, RDoc::RubyToken::TkREGEXP
          expr = StringExpression.new(@tk.line_no,@tk.char_no, @tk.text)
          get_tk
          # check for Ruby 2.2 Hash symbol (string directly followed by a COLON)
          if @tk.is_a?(RDoc::RubyToken::TkCOLON)
            expr = SymbolExpression.new(expr.line_no,expr.char_no,expr.name + ':')
            expr.text = expr.name
            get_tk
          end
          expr = parse_identifier_method_call(expr)
          expr = check_for_range_expression(expr)
          expr = check_for_hash_element_expression(expr)
        when RDoc::RubyToken::TkINTEGER, RDoc::RubyToken::TkFLOAT, RDoc::RubyToken::TkTRUE, RDoc::RubyToken::TkFALSE
          expr = NumberExpression.new(@tk.line_no,@tk.char_no,@tk.text)
          get_tk
          expr = parse_identifier_method_call(expr)
          expr = check_for_range_expression(expr)
          expr = check_for_hash_element_expression(expr)
        when RDoc::RubyToken::TkSYMBEG
          expr = SymbolExpression.new(@tk.line_no,@tk.char_no,'')
          get_tk
          if @tk.text =~ /^[a-z]{1,}[a-z0-9\_]*?$/ #is_a?(RDoc::RubyToken::TkIDENTIFIER)
            expr.set_text(':' + @tk.text)
            expr.name = ':' + @tk.text
            get_tk
            expr = parse_identifier_method_call(expr)
            expr = check_for_hash_element_expression(expr)
          else
            parse_error(@tk,"':' not followed by identifier or operator")
          end
        when RDoc::RubyToken::TkGVAR, RDoc::RubyToken::TkIVAR, RDoc::RubyToken::TkSELF, RDoc::RubyToken::TkNIL
          expr = parse_identifier
        when RDoc::RubyToken::TkCONSTANT, RDoc::RubyToken::TkIDENTIFIER
          expr = parse_identifier
          expr = check_for_hash_element_expression(expr)
        when RDoc::RubyToken::TkLBRACK
          expr = parse_array
          expr = parse_identifier_method_call(expr)
        when RDoc::RubyToken::TkLBRACE
          expr = parse_hash
          expr = parse_identifier_method_call(expr)
        when RDoc::RubyToken::TkKW
          # check for a Ruby 2.0 syntax hash key symbol (such as end: begin: class: case: etc...)
          if peek_tk.is_a?(RDoc::RubyToken::TkCOLON)
            ident_text, line, char = @tk.text, @tk.line_no, @tk.char_no
            get_tk
            expr = SymbolExpression.new(line,char,'')
            expr.set_text(ident_text + ':')
            expr.name = ident_text + ':'
            get_tk
            expr = check_for_hash_element_expression(expr)
          end
      end # case @tk
      expr
    end

    # parse an Array declaration <tt>[...]</tt>
    def parse_array
      get_tk
      array_expr = ArrayExpression.new(@tk.line_no,@tk.char_no)
      skip_white_space
      array_expr.elements << parse_expression
      skip_white_space
      while @tk.is_a?(RDoc::RubyToken::TkCOMMA) do
        get_tk
        array_expr.elements << parse_expression
        skip_white_space
      end
      unless @tk.is_a?(RDoc::RubyToken::TkRBRACK)
        parse_error(@tk,"']' expected but '#{@tk.text}' found")
      end
      get_tk
      array_expr
    end

    # Parse a +Hash+ declaration <tt>{ ... }</tt>
    def parse_hash
      @in_hash += 1
      get_tk
      hash_expr = HashExpression.new(@tk.line_no,@tk.char_no)
      skip_white_space
      hash_expr.elements << parse_hash_element
      skip_white_space
      while @tk.is_a?(RDoc::RubyToken::TkCOMMA) do
        get_tk
        hash_expr.elements << parse_hash_element
        skip_white_space
      end
      unless @tk.is_a?(RDoc::RubyToken::TkRBRACE)
        parse_error(@tk,"'}' expected but '#{@tk.text}' found")
      end
      get_tk
      @in_hash -= 1
      hash_expr
    end

    # parse a Hash element within a +Hash+ declaration
    def parse_hash_element
      el = HashElementExpression.new(@tk.line_no,@tk.char_no)
      el.key = parse_expression
      if el.key.is_a?(SymbolExpression) && el.key.text =~ /:$/
        skip_white_space
        el.value = parse_expression
        # get_tk
        return el
      else
        skip_white_space
        if @tk.is_a?(RDoc::RubyToken::TkASSIGN)
          get_tk
          if @tk.is_a?(RDoc::RubyToken::TkGT)
            get_tk
            skip_white_space
            el.value = parse_expression
            skip_white_space
            return el
          end
        end
      end
      parse_error(@tk,"'=>' expected but '#{@tk.text}' found")
    end

    # return a Hash of all translation entries we collected
    def translation_entries
      entries = {}
      self.translate_calls.each do |c|
        e = c.to_translation_entry(@relative_filename)
        if e.is_a?(Array)
          e.each do |te|
            if entries[te.source]
              entries[te.source].references += te.references
            else
              entries[te.source] = te
            end
          end
          elsif e.is_a?(TranslationEntry)
           if entries[te.source]
              entries[e.source].references += te.references
           else
              entries[e.source] = e
           end
        end
      end
      entries
    end
   end # class SourceParser
end # module ZLocalize
